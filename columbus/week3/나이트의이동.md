
### [ğŸ” ë‚˜ì´íŠ¸ì˜ ì´ë™](https://www.acmicpc.net/problem/7562)


#### 1ë‹¨ê³„) ë¬¸ì œ ë¶„ì„

1. ì…ë ¥
    - í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ê°œìˆ˜
    - ì²´ìŠ¤íŒ ê¸¸ì´ I, `4 â‰¤ l â‰¤ 300`
    - ë‚˜ì´íŠ¸ ì¶œë°œ ì§€ì 
    - ë‚˜ì´íŠ¸ ëª©ì ì§€
2. ìš”êµ¬ì‚¬í•­
    - ë‚˜ì´íŠ¸ê°€ í•œ ë²ˆì— ì´ë™í•  ìˆ˜ ìˆëŠ” ì¹¸ì€ ê·¸ë¦¼ê³¼ ê°™ìŒ
    - ì¶œë°œ ì§€ì ì—ì„œ ëª©ì ì§€ê¹Œì§€ì˜ ìµœì†Œ ì´ë™ ì¹¸
3. ì‹œê°„ë³µì¡ë„
    - **ë…¸ë“œ ë²”ìœ„ê°€ 90,000:**Â ì‹œê°„ ë³µì¡ë„ê°€Â Â `O(NlogN)`Â Â ì´í•˜ì¸ ì•Œê³ ë¦¬ì¦˜ì„ ì„¤ê³„í•´ì•¼ í•œë‹¤.
4. ì œì•½ì¡°ê±´

   x

#### 2ë‹¨ê³„) ì ‘ê·¼ ë°©ì‹

- ìƒê° ê³¼ì • ì„¤ëª…
   1. bfs ë°©ì‹ìœ¼ë¡œ íŠ¹ì • ìœ„ì¹˜ì—ì„œ ì´ë™ì˜ ê²½ìš°ì˜ ìˆ˜ë¥¼ íƒìƒ‰í•œë‹¤.
   2. DP ë°©ì‹ìœ¼ë¡œ ì´ì „ ìœ„ì¹˜ì—ì„œ ìµœì†Œ distance ê¸°ë°˜ìœ¼ë¡œ í˜„ì¬ ìœ„ì¹˜ì˜ ìµœì†Œ distance ë¥¼ êµ¬í•´ë‚˜ê°„ë‹¤.
      1. ì²˜ìŒ ê¸°ë¡ë˜ëŠ” distance ê°€ ìµœì†Œ distance 

- ê³ ë ¤í•œ ì˜ˆì™¸ ì¼€ì´ìŠ¤

  x


### 3ë‹¨ê³„) ì½”ë“œ ì„¤ê³„

1. ì…ë ¥ì„ ë°›ëŠ”ë‹¤.

    ```
     int T = Integer.parseInt(br.readLine());
     StringTokenizer st;
     while (T-- > 0) {
            int I = Integer.parseInt(br.readLine());
            st = new StringTokenizer(br.readLine());
            int fromR = Integer.parseInt(st.nextToken());
            int fromC = Integer.parseInt(st.nextToken());
            st = new StringTokenizer(br.readLine());
            int toR = Integer.parseInt(st.nextToken());
            int toC = Integer.parseInt(st.nextToken());
    ```

2. bfs ë°©ì‹ìœ¼ë¡œ íƒìƒ‰í•œë‹¤.
    1. `IxI` `distance` ë°°ì—´ì„ ë§Œë“¤ê³ , ê°’ì„ -1ë¡œ ì´ˆê¸°í™”í•œë‹¤.
    2. ì‹œì‘ ì§€ì ì„ íì— ë„£ëŠ”ë‹¤. `distance` ë¥¼ 0ìœ¼ë¡œ í•œë‹¤.
    3. íì—ì„œ ê°’ì„ ë¹¼ë©° ê°€ëŠ¥í•œ ì§€ì ì„ íƒìƒ‰í•œë‹¤.
       1. í•´ë‹¹ ì§€ì ì˜ `distance` ê°’ì´ -1ì¼ ë•Œ
          - í˜„ì¬ ì§€ì  distance = ì´ì „ ì§€ì  distance + 1
          - íì— í˜„ì¬ ì§€ì ì„ ë„£ëŠ”ë‹¤.
    4. ëª©ì ì§€ì ì˜ `distance` ë°˜í™˜í•œë‹¤.

   ```
   static int[][] drdc = new int[][]{
            {-2, -1}, {-1, -2},
            {-2, 1}, {-1, 2},
            {2, -1}, {1, -2},
            {2, 1}, {1, 2}
    };
   
   static int bfs(int I, int fromR, int fromC, int toR, int toC) {
        int[][] distance = new int[I][I];
        for (int i = 0; i < I; i++) {
            Arrays.fill(distance[i], -1);
        }

        Queue<int[]> q = new LinkedList<>();
        q.add(new int[]{fromR, fromC});
        distance[fromR][fromC] = 0;

        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int r = cur[0];
            int c = cur[1];

            for (int[] d : drdc) {
                int nextR = d[0] + r;
                int nextC = d[1] + c;

                if (nextR >= I || nextR < 0 || nextC >= I || nextC < 0)
                    continue;

                if (distance[nextR][nextC] == -1) {
                    distance[nextR][nextC] = distance[r][c] + 1;
                    q.add(new int[]{nextR, nextC});
                }
            }
        }

        return distance[toR][toC];
    }
   ```

3. íƒìƒ‰ ê²°ê³¼ë¥¼ ì¶œë ¥í•œë‹¤.
   ```
   System.out.println(bfs(I, fromR, fromC, toR, toC));
   ```
